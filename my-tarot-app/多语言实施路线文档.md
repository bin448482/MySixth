# 多语言本地化实施计划

## 1. 目标与范围
- 支持至少中英文双语，形成可扩展至更多语言的基座。
- 覆盖 Expo React Native 前端的所有用户可见字符串，并为后续 Web/Admin/Backend 同步策略预留空间（本计划聚焦前端）。
- 提供语言自动检测、手动切换与持久化；确保 AI 交互、离线数据等流程中文案一致。
- 建立翻译资源管理、开发流程与质量保障机制。

## 2. 现状简述
- 目录结构：`app/` 页面、`components/` 组件库、`lib/` 业务逻辑与上下文、`assets/` 静态资源。
- Context：`lib/contexts/AppContext.tsx` 管理应用初始化状态；`lib/contexts/ReadingContext.tsx` 管理占卜流程。
- 数据：SQLite 双库（配置 + 用户），服务层 `lib/services/` 封装业务逻辑。
- 当前文本以硬编码中文为主，尚未引入多语言库或翻译资源。

## 3. 技术架构设计
### 3.1 库与基础设施
- 采用 `react-i18next` + `i18next` 作为国际化核心，集成 `expo-localization` 获取设备语言。
- 新增 `lib/i18n/`：
  - `index.ts`: i18next 初始化、资源加载、语言切换方法。
  - `resources.ts`: 输出命名空间映射，方便动态扩展。
  - `types.ts`: 提供翻译 Key 的 TypeScript 类型（使用 `react-i18next` 的类型增强）。
- 资源放置：`assets/i18n/<locale>/<namespace>.json`，命名空间建议按功能模块划分（如 `home`, `reading`, `cards`, `settings`, `common`）。

### 3.2 全局状态与持久化
- 在 `AppContext` 中维护 `locale`, `setLocale`, `availableLocales`。
- 首次启动流程：
  1. 读取用户数据库（或 AsyncStorage 兜底）中的语言偏好。
  2. 若无偏好，使用设备语言 → 若不在支持列表内则回退至默认语言（中文）。
  3. 将最终语言写回本地存储，触发 i18next 初始化。
- 语言切换持久化到用户数据库表（新增 `settings` 表或扩展现有用户数据结构）；离线场景可读取本地值。

#### 数据库改造计划
1. **表结构调整**
   - 直接重建 `user_history` 表：新增 `locale` 列（默认值 `zh-CN`），确保 `result.metadata.locale` 同步写入。
   - 新建 `user_settings` 表（`id` PK、`user_id` UNIQUE、`locale`、`updated_at`、`synced_at` 可选字段）用于保存语言偏好及后续配置项。
   - 因当前为新开发阶段，可删除现有用户数据库再以最新 schema 重建，避免维护迁移脚本。
2. **Schema 与初始化文件**
   - 更新 `lib/database/schema.ts`、`initializer.ts`，让初始建库脚本在创建时包含上述新结构。
   - 若有预置 SQL（如 `assets/db/tarot_user_data.db` 初始化逻辑），同步更新。
3. **服务层更新**
   - 在 `UserDatabaseService` 中新增读写语言偏好接口（`getUserLocale`, `setUserLocale`），`saveUserHistory` 写入 `locale`。
   - `HistoryService` 保存/读取时传递语言信息，并在导出、统计接口中附带 `locale` 字段。
4. **测试点**
   - 单元测试：验证新接口、表结构重建流程。
   - 手工测试：切换语言后生成历史记录，确认 `locale` 字段与展示文案一致。

#### 配置数据库（`tarot_config.db`）调整计划
1. **结构重建**
   - 删除现有 `tarot_config.db`，按照新 schema 重建（当前阶段无生产数据压力）。
   - 基础表保留结构化信息（如 `card`, `dimension`, `spread`），文本字段改为存储默认语言或精简为 ID 关联。
   - 新增翻译表：
     - `card_translation(card_id, locale, name, deck, UNIQUE(card_id, locale))`
     - `card_interpretation_translation(interpretation_id, locale, summary, detail, UNIQUE(interpretation_id, locale))`
     - `dimension_translation(dimension_id, locale, name, description, aspect)`
     - `spread_translation(spread_id, locale, name, description)`
   - 统一使用 `TEXT COLLATE NOCASE` 便于按语言检索。
2. **数据准备**
   - 以中文基础词条为源，整理英文等语言版本；可借助 `tarot-ai-generator` 项目批量生成初稿再人工校对。
   - 建立脚本（Node/TS 或 Python）将多语言 JSON 导入 SQLite，输出最新 `tarot_config.db`。
3. **服务层适配**
   - 更新 `ConfigDatabaseService` 查询方法，在获取卡牌/解读时根据当前 `locale` 联结翻译表，未命中时回退默认语言。
   - `CardService`, `CardInterpretationService`, `DimensionService`, `SpreadService` 等全部改为语言感知接口（如新增 `getCardById(id, locale)`）。
   - TypeScript 类型中补充 `locale` 字段或国际化内容结构，保持 API 一致。
4. **测试验证**
   - 单元测试：验证同一 ID 在不同语言下返回正确文本、无 SQL 错误。
   - 手工测试：检查卡牌列表、详情、牌阵说明等多语言展示；确认无缺失词条时降级到默认语言。
   - CI 中增加数据库结构校验脚本，防止导入过程遗漏表或索引。

#### 后端 API 与 LLM 策略
1. **接口入参**
   - 为 `/readings/analyze` 与 `/readings/generate` 增加 `locale` 字段或读取 `Accept-Language`，默认回退 `zh-CN`。
   - 认证失败、积分不足等错误提示统一走多语言字典（JSON + i18n 中间层），避免硬编码中文。
2. **LLM 调度**
   - 在 `reading_service` 中根据 locale 或地区设置分流至不同 provider：
     - 国内：使用智谱/自建大模型，保留中文 prompt。
     - 国际：使用 OpenAI 等，可切换英文 prompt 与输出。
   - 抽象 `LLMProvider` 接口：`get_provider(locale)` 返回对应实例，prompt 模板按语言拆分维护。
3. **默认回退与日志**
   - 如果目标语言缺失 prompt 或翻译，回退默认语言并记录 warning，避免调用失败。
   - LLM 返回结构解析失败时，错误信息也需通过本地化字典输出。
4. **测试与监控**
   - 为两套 LLM 提供独立的集成测试数据，用于验证 prompt 语言与输出格式。
   - 在监控中区分国内/国际调用成功率与耗时，便于后续优化。

### 3.3 组件与页面改造
- 建立 `lib/hooks/useTranslation.ts` 封装 `useTranslation` 并导出命名空间常量。
- 分阶段将页面与组件中的硬编码字符串替换为 `t('namespace:key')` 调用。
- 处理动态插值、复数、日期格式（可结合 `Intl.NumberFormat`、`Intl.DateTimeFormat`）。
- 为可能的 RTL 语言预留布局调整接口（如使用 `I18nManager`，暂不启用但设计时避免绝对定位依赖）。

### 3.4 配合 AI 与服务层
- 在向后端发起 AI 请求时附带语言信息（如 header `x-user-locale` 或请求体字段 `locale`），便于后端生成对应语种。
- 卡牌、占卜历史等本地数据库展示字段如需多语言，应在后续数据层升级时同步规划；当前阶段先聚焦界面文案。

## 4. 实施路线
### 阶段一：基础设施搭建
1. 添加依赖 `i18next`, `react-i18next`, `i18next-browser-languagedetector`（若需）与 `expo-localization`。
2. 建立 `lib/i18n/` 初始化模块，配置默认语言、资源加载、错误日志。
3. 创建基础资源文件（`zh-CN/common.json`, `en/common.json` 等）并录入核心通用词条。
4. 在应用入口（`App.tsx` / `AppContext` 初始化流程）中引入 i18n，确保页面可访问翻译。

### 阶段二：全局状态与设置页
1. 在 `AppContext` 注入语言状态与切换逻辑；提供 Hook `useLocale()`。
2. 在 `settings` 模块新增语言选择 UI（基于现有设置组件），可显示当前语言、支持列表、切换按钮。
3. 实现语言切换后刷新逻辑，确保上下文化、加载指示与错误提示均被翻译。

### 阶段三：模块逐步替换
1. 优先处理用户路径关键界面：
   - 首页 `app/(tabs)/index.tsx` + `components/home/*`
   - 占卜流程 `app/(reading)/` + `components/reading/*`
   - 历史记录 `app/(history)/`
2. 随后覆盖次要/信息类页面：`app/cards/`, `app/settings/`, 通用组件。
3. 对应地产出/更新命名空间 JSON，并确保 key 命名一致。

### 阶段四：验证与优化
1. 编写自动/手动检查脚本：
   - `yarn lint:i18n`: 检测硬编码字符串（可用简单的正则或 ESLint 插件）。
   - `yarn verify:i18n`: 检查翻译 key 缺失、JSON 格式是否有效。
2. 在 Expo 设备/模拟器上手动测试语言切换；确认导航标题、Toast、Modal 等多处文案。
3. 评估性能：确认资源懒加载、避免在渲染期间同步读取文件。
4. 更新文档（如 `components/.../CLAUDE.md`, `lib/i18n/CLAUDE.md`）记录使用方式。

## 5. 任务分解与协作接口
- **工程改造**：i18n 初始化、Context 扩展、设置页 UI。
- **翻译管理**：建立词条 Excel/Notion 对应 JSON 的导入流程；定义 key 命名规范。
- **测试保障**：在 QA 测试用例中增加多语言场景，覆盖全流程。
- **后端联动（可选）**：定义 AI 接口语言参数；必要时调整返回结构。

## 6. 风险与应对
- **风险**：翻译资源缺失 → **应对**：默认回退至中文并在控制台记录缺失 key。
- **风险**：语言切换导致 UI 布局溢出 → **应对**：在设计/开发时确保容器可包裹长文本，使用 `flex` 而非固定宽度。
- **风险**：初始化竞态（语言未设定即渲染） → **应对**：在 AppContext 中等待 i18n 就绪后再渲染路由。
- **风险**：离线模式下无法加载新语言 → **应对**：提前将支持语言资源打包在应用内；动态下载需另行设计。

## 7. 测试与发布流程
- **开发测试**：模拟器切换系统语言 + 应用内切换，验证核心流程。
- **自动化检查**：在 CI 新增翻译文件 JSON 校验脚本。
- **回归测试**：重点覆盖支付入口（待实现）、AI 占卜流程、历史记录查看等关键路径。
- **发布节奏**：建议按阶段结束后合并到主分支，再通过 EAS 内测包验证，确认无回归后发布。

---
如需跨端（Web 管理后台、后端）协作，请在阶段一完成后同步对接，确保词条与接口策略一致。
